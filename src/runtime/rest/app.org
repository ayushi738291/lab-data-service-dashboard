#+TITLE: The Flask Web Server
#+AUTHOR: VLEAD
#+DATE: [2017-06-05 Mon]
#+SETUPFILE: ../../org-templates/level-2.org
#+TAGS: boilerplate(b)
#+EXCLUDE_TAGS: boilerplate
#+OPTIONS: ^:nil

* Introduction
  The application that runs the FLASK Web App.


* __INIT__ FILE
This is the __init__.py file in which the app is being configured 
and also login manager is configured.
Blueprint =api= is registered in this file.
Here we initialize our application using flask, it will be referred to as app and import the configuration from the config file,
which in our case is flask_app_config.py.
Further we go on build a database, which is managed by SQLAlchemy.
Then a Login Manager for our app was defined just to make add the user in the session to our =current_user= object provided by the Flask.
Further an OAuth for our app is initialized that can be used for Google OAuth login using the Google OAuth credentials.

#+NAME: configure
#+BEGIN_SRC python 
app = Flask(__name__)
app.config.from_object("runtime.config.flask_app_config")
app.config['TRAP_HTTP_EXCEPTIONS']=True

db = SQLAlchemy(app)

login_manager = LoginManager(app)
login_manager.login_view = "users.login"
login_manager.session_protection = "strong"
oauth = OAuth()
#+END_SRC


* Error Handling
This is error handler function. It returns 404.html file when 
an error is raised.
App 404 error handler, redirects to 404.html whenever non exitent/registered
route is tried to be accessed.
App 405 error handler, redirects to 405.html whenever a existing/registered
route is tried to be accessed using a method which is not allowed.

#+NAME: error_handling
#+BEGIN_SRC python
@app.errorhandler(404)
def handle_404(e):
    return render_template('404.html'), 404

@app.errorhandler(405)
def handle_404(e):
    return render_template('405.html'), 405
#+END_SRC


* Roles
** Admin Authorisation
This function checks if the user logged in is =Admin= or not.
If no user is logged in, it return a JSON object with a message
=Unauthorized= and success as =False=.
If the user logged in is guest , it returns a JSON object with
a message and success as =False=.
If the user logged in is admin, function becomes true.
#+NAME: admin_auth
#+BEGIN_SRC python  
#Custom decorator declartions to segregrate CRUD functionality available to an
#user on the basis of his/her role.  1. Admin
def requires_admin_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        if app.config['TESTING'] and app.config['LOGIN_DISABLED']:
            return f(*args, **kwargs) 
        if 'type' not in session:
            return jsonify(message="Unauthorized", success=False), 401
        if session['type'] != 'admin':
            return jsonify(message="Sorry,you are not admin. \
                        You Dont have access to this", success=False), 401
        return f(*args, **kwargs)
    return decorated


#+END_SRC

** Guest Authorisation

This function checks if the user logged in is =Guest= or not.
If no user is logged in, it return a JSON object with a message
=Unauthorized= and success as =False=.
If the user logged in has another role , it returns a JSON object with
a message and success as =False=.
If the user logged in is guest, function becomes true.
#+NAME: guest_auth
#+BEGIN_SRC python
#2. Guest (Redundant as of now, should be used when more roles are added.)
def requires_guest_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        if app.config['TESTING'] and app.config['LOGIN_DISABLED']:
            return f(*args, **kwargs)
        if 'type' not in session:
            return jsonify(message="Unauthorized", success=False), 401
        if session['type'] != 'guest':
            return jsonify(message="Unauthorized", success=False), 401
        return f(*args, **kwargs)
    return decorated
#+END_SRC


* Routes acess via Only AJAX
We wanted to restrict entry to some routes through AJAX calls only, this would be
helping us to not worry about users getting to know about server implemented route
and their access to it. 

#+NAME: only_ajax
#+BEGIN_SRC python
#3. Check wether the request has been made by an AJAX call or not
def disable_access_on_hash(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        if app.config['TESTING'] and app.config['LOGIN_DISABLED']:
            return f(*args, **kwargs)
        if request.is_xhr:
            return f(*args, **kwargs)
        else:
            return jsonify(message="Unauthorized", success=False), 401
    return decorated
#+END_SRC


* Login Managar
LoginManager decorated user_loader function is defined  which allow Flask to intialise current_user object on its own, If your
models are declared in a separate module, we need to import them before calling according to Flask documentation.

#+NAME: login_manager
#+BEGIN_SRC python 

from runtime.rest.app.users.db import User, Roles
db.create_all()

@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))
#+END_SRC


* Register Blueprint(s)
  Here we register blueprint(s) which is generally a template for generating main
  section of our web application. In order to visit the routes in our api we need 
  to register our blueprint (like in unittesting).
#+NAME: blueprints
#+BEGIN_SRC python 

from runtime.rest.app.users.api import api
app.register_blueprint(api)
#+END_SRC


* Socket
Workaround for socket file pipes not getting enough time to restart while
changes are made in debugger mode. ~I am trying to find a better solutions to this~.
#+NAME: socket_workaround
#+BEGIN_SRC python 

time.sleep(3)
#+END_SRC


* SSL
  We initially decided to host our app over =HTTPS= instead of =HTTP=. Hence in order to do so we need
  SSL certificates for it. This function is supposed to create the required files for the developing.
** SSL_DEVCERT
#+NAME: ssl_devcert
#+BEGIN_SRC python :tangle cert.py

from werkzeug.serving import make_ssl_devcert
make_ssl_devcert('./ssl', host='localhost')

#+END_SRC


* Run Server
#+NAME: run_server
#+BEGIN_SRC python :tangle run.py
from app import app as application

if __name__ == '__main__':
	application.run(host = "localhost", debug = True,
                        ssl_context = ('./ssl.crt', './ssl.key'))

#+END_SRC


* Imports
  
#+NAME: imports
#+BEGIN_SRC python
# Import flask modules and template operators
from flask import Flask, render_template, request, session, jsonify
from flask_oauth import OAuth
from flask_login import LoginManager, login_required, login_user, \
    logout_user, current_user, UserMixin
from flask_sqlalchemy import SQLAlchemy
import os
import time
from functools import wraps
#+END_SRC
  

* Tangle
#+BEGIN_SRC python :tangle app/__init__.py :eval no :noweb yes 
<<imports>>
<<configure>>
<<admin_auth>>
<<guest_auth>>
<<only_ajax>>
<<error_handling>>
<<login_manager>>
<<blueprints>>
<<socket_workaround>>
#+END_SRC
